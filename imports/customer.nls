; NetLogo Customer NLS file
; Customer is a turtle
breed [customers customer]
customers-own [
  basket
  shopping-list
  selected-product
  selected-shelf
  tolerance
]

; Spawns customer
to spawn-customer [num_customers]
  set customers-alive (customers-alive + num_customers)
  create-customers num_customers [
    set tolerance random 26 + 25 ;sets random tolerance between 25-50
    set basket []
    set shopping-list generate-bucket-list
    set selected-shelf -1
    ;set selected-product 
    move-to one-of patches with [pcolor = green ]
    set color grey
    set shape "person"
    set size 2
  ]
  
end

to choose-product
  if not empty? shopping-list [
    let product first shopping-list
    set selected-product item 0 product
  ]
end

; Move customer
to move-customer
  ; Close-shelf contains the patch of the nearest shelf
  ; with a certain id. 1 is a placeholder here.
  let close-shelf get-closest-shelf 1
  
  ; Close-path contains the patch of the nearest patch
  ; to the chosen shelf.
  let close-path get-closest-floor-to-shelf [shelf_id] of close-shelf
  
  
  ; This goes to a nearby patch to the chosen shelf
  go-to-floor [shelf_id] of close-path
  
  print shopping-list ;print shopping list of customer
  
  ;if customer reaches the floor of target shelf
  if(patch-here = close-path)[
    let prodid [product_id] of close-shelf
    let prodindex 0
    
    ;check for every item in shopping list
    foreach shopping-list [ a ->
      let bucket-item-id item 0 a
      let bucket-item-quantity item 1 a
      let shelf-quantity 0
      let found false
      
      ;if item in shelf is in bucket list
      if(bucket-item-id = prodid)[  
        ;reduce quantity of item in the shelf
        ask patches with [shelf_id = ([shelf_id] of close-shelf)] [
          set shelf-quantity product_quantity ; shelf quantity is a temp variable to use value of product_quantity outside of "ask patches"
          set found true
          ifelse (bucket-item-quantity <= product_quantity)[
            set product_quantity product_quantity - bucket-item-quantity
          ]
          [
            set product_quantity 0
          ]
        ]
        
        ;update bucket list and basket
        ifelse (bucket-item-quantity <= shelf-quantity and found = true)[
          ;remove from shopping list when shelf quantity is equal or bigger than required
          add-basket (item prodindex shopping-list) 
          set shopping-list remove-item prodindex shopping-list 
        ]
        [
          ;else update quantity
          let replacement-item []
          set replacement-item lput bucket-item-id replacement-item
          set replacement-item lput (bucket-item-quantity - shelf-quantity) replacement-item
          set shopping-list replace-item prodindex shopping-list replacement-item
          
          ;; CURRENTLY DOES NOT HANDLE SITUATIONS WHERE ITEM IS GRABBED TWICE (for restocking) -> WOULD HAVE 2 OF THE SAME ITEMS ON THE 
          ;; BASKET WITH DIFFERENT QUANTITIES INSTEAD OF UPDATING THE QUANTITY OF THE PREVIOUS
          ;; Basket would look something like this -> [[4 1] [4 2]] instead of [[4 3]]
          let basket-item []
          set basket-item lput bucket-item-id basket-item
          set basket-item lput shelf-quantity basket-item
          add-basket basket-item 
        ]
      ]
      set prodindex prodindex + 1
    ]
    print("After for each")
    print ("quantity of shelf is ")
    print [product_quantity] of close-shelf
    print ("bucket list is now ")
    print shopping-list
    print ("basket is ")
    print basket
  ]
  ; This must be called once shopping is done. Will not work if immediately called.
  ; It assumes customer is at any patch behind the cashier line.
  ;go-to-closest-cashier
  
  
  ; For debugging nearby shelf movement.
  ;print close-shelf
  ;print "Floor: "
  ;print close-path
  
  if customers-alive > tolerance [
    let exit-patch one-of patches with [pcolor = red]
    face exit-patch
    customer-move-forward
  ]
  ; This sends the customer to exit.
  ;let exit-patch one-of patches with [pcolor = red]
  ;face exit-patch
  ;fd 1
  if pcolor = red [
    set customers-alive (customers-alive - 1)
    die
  ]
  
end

to customer-move-forward
  ; This is now the main procedure used for all move operations with customer.
  fd customer-movement-speed / 100
end




to add-basket [grocery_item]
  set basket lput grocery_item basket
end

to-report generate-bucket-list
  let num-items random 10
  let cur-items 0
  let bucket []
  
  loop [
    let item-id (random (length data - 1)) + 1  ; Subtracts the header from length and adds one to skip header.
    let bucket-item-data grab-item-data item-id
    
    ; Format of list is [itemid, amount]
    let bucket-item []
    set bucket-item lput (item 0 bucket-item-data) bucket-item  ; Puts ID to bucket-item
    set bucket-item lput 1 bucket-item  ; Quantity becomes 1 by default since new item.
    
    let found false  ; For skipping last few lines in case dupe is found
    
    if ((length bucket) >= 1)
    [
      let fcounter 0  ; For indexing
      
      ; While haven't reached end of bucket list:
      while [fcounter < length bucket]
      [
        let dupe (item fcounter bucket)        ; Grab item (like for each)
        if (item 0 bucket-item = item 0 dupe)  ; Check if same item id
        [
            let quantity (item 1 dupe) + 1
            let new-item []                           ; Creates a new item
            set new-item lput (item 0 dupe) new-item  ; id
            set new-item lput quantity new-item       ; quantity
            
            ; Replaces existing item with new-item (in order to update quantity)
            set bucket (replace-item fcounter bucket new-item)
            
            set fcounter (length bucket)  ; Force stop
            set found true  ; To skip add bucket repeating lines
    
        ]  ; Found duplicate
        set fcounter (fcounter + 1)  ; Increment index
      ]
    ]
    
    if (found = false) 
    [
      set bucket lput bucket-item bucket  ; Adds to bucket 
    ]
    
    set cur-items (cur-items + 1)  ; Increment number of items
    if cur-items >= num-items [ report bucket ]  ; Report bucket if reached max items
    
  ]

end


