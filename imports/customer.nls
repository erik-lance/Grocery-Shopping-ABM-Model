; NetLogo Customer NLS file
; Customer is a turtle
breed [customers customer]
customers-own [
  basket
  shopping-list
  selected-product
  selected-shelf
  tolerance
]

; Spawns customer
to spawn-customer [num_customers]
  set customers-alive (customers-alive + num_customers)
  create-customers num_customers [
    set tolerance random 26 + 25 ;sets random tolerance between 25-50
    set basket []
    set shopping-list generate-bucket-list
    set selected-shelf -1
    ;set selected-product 
    move-to one-of patches with [pcolor = green ]
    set color grey
    set shape "person"
    set size 2
  ]
  
end

to choose-product
  let product first shopping-list
  set selected-product item 0 product
end

; Move customer
to move-customer
  ; Will only pick up items as long as shopping list isn't empty
  if not empty? shopping-list 
  [
    ; Grabs the first item in shopping-list every time
    choose-product

    ; Close-shelf contains the patch of the nearest shelf
    ; with a certain id. 1 is a placeholder here.
    let close-shelf get-closest-shelf selected-product
  
    ; Close-path contains the patch of the nearest patch
    ; to the chosen shelf.
    let close-path get-closest-floor-to-shelf [shelf_id] of close-shelf
  
  
    ; This goes to a nearby patch to the chosen shelf
    go-to-floor [shelf_id] of close-path
  
    ;if customer reaches the floor of target shelf
    if(patch-here = close-path)[
      let prodid [product_id] of close-shelf
      let prodindex 0
      
      ;check for every item in shopping list
      foreach shopping-list [ a ->
        let bucket-item-id item 0 a
        let bucket-item-quantity item 1 a
        let shelf-quantity 0
        
        ;if item in shelf is in bucket list
        if(bucket-item-id = prodid)[  
          ;reduce quantity of item in the shelf
          ask patches with [shelf_id = ([shelf_id] of close-shelf)] [
            set shelf-quantity product_quantity ; shelf quantity is a temp variable to use value of product_quantity outside of "ask patches"
          ]
          
          add-basket (item prodindex shopping-list) 
          set shopping-list remove-item prodindex shopping-list 
        ]
        set prodindex prodindex + 1
      ]
    ]
  ]

  ; This must be called once shopping is done. Will not work if immediately called.
  ; It assumes customer is at any patch behind the cashier line.
  if empty? shopping-list
  [
    go-to-closest-cashier
  ]
  
  if customers-alive > tolerance [
    let exit-patch one-of patches with [pcolor = red]
    face exit-patch
    customer-move-forward
  ]
  ; This sends the customer to exit.
  ;let exit-patch one-of patches with [pcolor = red]
  ;face exit-patch
  ;fd 1
  if pcolor = red [
    set customers-alive (customers-alive - 1)
    die
  ]
  
end

to customer-move-forward
  ; This is now the main procedure used for all move operations with customer.
  fd customer-movement-speed / 100
  ; Check for collisions, increment counter if distance < 2
  ask turtles
  [ let nearest min-one-of turtles [distance myself]
    if distance nearest < 2 [ set collisions (collisions +1) ]
  ]
end




to add-basket [grocery_item]
  set basket lput grocery_item basket
end

to-report generate-bucket-list
  let num-items random max-items
  let cur-items 0
  let bucket []
  
  loop [
    let item-id (random (length data - 1)) + 1  ; Subtracts the header from length and adds one to skip header.
    let bucket-item-data grab-item-data item-id
    
    ; Format of list is [itemid, amount]
    let bucket-item []
    set bucket-item lput (item 0 bucket-item-data) bucket-item  ; Puts ID to bucket-item
    set bucket-item lput 1 bucket-item  ; Quantity becomes 1 by default since new item.
    
    let found false  ; For skipping last few lines in case dupe is found
    
    if ((length bucket) >= 1)
    [
      let fcounter 0  ; For indexing
      
      ; While haven't reached end of bucket list:
      while [fcounter < length bucket]
      [
        let dupe (item fcounter bucket)        ; Grab item (like for each)
        if (item 0 bucket-item = item 0 dupe)  ; Check if same item id
        [
            let quantity (item 1 dupe) + 1
            let new-item []                           ; Creates a new item
            set new-item lput (item 0 dupe) new-item  ; id
            set new-item lput quantity new-item       ; quantity
            
            ; Replaces existing item with new-item (in order to update quantity)
            set bucket (replace-item fcounter bucket new-item)
            
            set fcounter (length bucket)  ; Force stop
            set found true  ; To skip add bucket repeating lines
    
        ]  ; Found duplicate
        set fcounter (fcounter + 1)  ; Increment index
      ]
    ]
    
    if (found = false) 
    [
      set bucket lput bucket-item bucket  ; Adds to bucket 
    ]
    
    set cur-items (cur-items + 1)  ; Increment number of items
    if cur-items >= num-items [ report bucket ]  ; Report bucket if reached max items
    
  ]

end


