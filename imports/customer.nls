; NetLogo Customer NLS file
; Customer is a turtle
breed [customers customer]
customers-own [
  basket
  shopping-list
  selected-product
  selected-shelf
  tolerance
]

; Spawns customer
to spawn-customer [num_customers]
  set customers-alive (customers-alive + num_customers)
  create-customers num_customers [
    set tolerance random 26 + 25 ;sets random tolerance between 25-50
    set basket []
    set shopping-list generate-bucket-list
    set selected-shelf -1
    ;set selected-product 
    move-to one-of patches with [pcolor = green ]
    set color grey
    set shape "person"
    set size 2
  ]
  
end

to choose-product
  if not empty? shopping-list [
    let product first shopping-list
    set selected-product item 0 product
  ]
end

; Move customer
to move-customer
  ; Close-shelf contains the patch of the nearest shelf
  ; with a certain id. 1 is a placeholder here.
  let close-shelf get-closest-shelf 1
  
  ; Close-path contains the patch of the nearest patch
  ; to the chosen shelf.
  let close-path get-closest-floor-to-shelf [shelf_id] of close-shelf
  
  
  ; This goes to a nearby patch to the chosen shelf
  go-to-floor [shelf_id] of close-path
  
  
  ; This must be called once shopping is done. Will not work if immediately called.
  ; It assumes customer is at any patch behind the cashier line.
  ;go-to-closest-cashier
  
  
  ; For debugging nearby shelf movement.
  ;print close-shelf
  ;print "Floor: "
  ;print close-path
  
  if customers-alive > tolerance [
    let exit-patch one-of patches with [pcolor = red]
    face exit-patch
    customer-move-forward
  ]
  ; This sends the customer to exit.
  ;let exit-patch one-of patches with [pcolor = red]
  ;face exit-patch
  ;fd 1
  if pcolor = red [
    set customers-alive (customers-alive - 1)
    die
  ]
  
end

to customer-move-forward
  ; This is now the main procedure used for all move operations with customer.
  fd customer-movement-speed / 100
end




to add-basket [grocery_item]
  
end

to-report generate-bucket-list
  let num-items random 10
  let cur-items 0
  let bucket []
  
  loop [
    let item-id (random (length data - 1)) + 1  ; Subtracts the header from length and adds one to skip header.
    let bucket-item-data grab-item-data item-id
    
    ; Format of list is [itemid, amount]
    let bucket-item []
    set bucket-item lput (item 0 bucket-item-data) bucket-item  ; Puts ID to bucket-item
    set bucket-item lput 1 bucket-item  ; Quantity becomes 1 by default since new item.
    
    let found false  ; For skipping last few lines in case dupe is found
    
    if ((length bucket) >= 1)
    [
      let fcounter 0  ; For indexing
      
      ; While haven't reached end of bucket list:
      while [fcounter < length bucket]
      [
        let dupe (item fcounter bucket)        ; Grab item (like for each)
        if (item 0 bucket-item = item 0 dupe)  ; Check if same item id
        [
            let quantity (item 1 dupe) + 1
            let new-item []                           ; Creates a new item
            set new-item lput (item 0 dupe) new-item  ; id
            set new-item lput quantity new-item       ; quantity
            
            ; Replaces existing item with new-item (in order to update quantity)
            set bucket (replace-item fcounter bucket new-item)
            
            set fcounter (length bucket)  ; Force stop
            set found true  ; To skip add bucket repeating lines
    
        ]  ; Found duplicate
        set fcounter (fcounter + 1)  ; Increment index
      ]
    ]
    
    if (found = false) 
    [
      set bucket lput bucket-item bucket  ; Adds to bucket 
    ]
    
    set cur-items (cur-items + 1)  ; Increment number of items
    if cur-items >= num-items [ report bucket ]  ; Report bucket if reached max items
    
  ]

end


